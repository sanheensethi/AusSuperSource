2) Manifest Schema (per route/page)

Produce manifest.json with this shape:

{
  "routeId": "string",
  "version": "semver",
  "kpis": [
    {
      "id": "snake_case_id",
      "selector": "css",
      "type": "integer|string|float|datetime|boolean",
      "wait": { "timeoutMs": 0, "stableForMs": 0 },
      "visibleWhen": [
        { "type": "state|dom|domAttr|actionCompleted", "path": "dot.path", "selector": "css", "name": "attr", "equals": {} }
      ]
    }
  ],
  "actions": [
    {
      "id": "dot.namespace",
      "dispatch": { "type": "PascalCaseCommand", "payloadSchema": { "field": "string|number|boolean" } },
      "effects": [
        { "emits": "kpiUpdate|stateChange|dom", "kpiId": "snake_case_id", "path": "dot.path", "selector": "css" }
      ],
      "errors": ["VALIDATION","UNAUTH","LIMIT","CONFLICT","EXCEPTION"]
    }
  ],
  "lists": [
    { "id": "list_name",
      "selector": "css",
      "row": "css",
      "cols": { "fieldId": "css" }
    }
  ],
  "forms": [
    { "id": "form_id",
      "selector": "css",
      "fields": [{ "id": "form.fieldId", "selector": "css" }]
    }
  ]
}


Rules

Every selector must match an element in the provided HTML.

Every action must have coded error set.

At least one visibleWhen per KPI in async UIs (use readiness or state).


3) Capabilities Pack Schema (per route)

Produce capabilities.json for the route:

{
  "routeId": "string",
  "capabilities": [
    {
      "id": "dot.namespaced.capability",
      "type": "kpi|action|form|view",
      "critical": true,
      "tags": ["string"],
      "source": { "page": "routeId", "kpiId": "snake_case_id", "actionId": "dot.namespace" }
    }
  ],
  "manifest": "/agent-assets/manifests/<routeId>.json",
  "version": "semver"
}


Rules

Include a capability for each KPI and action in the manifest.

Use meaningful tags (e.g., ["todo","list"]).

4) Bridge Contract (frontend API)

If not present, emit/patch a minimal bridge:

declare global { interface Window { __APP_BRIDGE__?: any } }

window.__APP_BRIDGE__ = {
  version: "1.0.0",

  // discovery
  getWellKnown: () => fetch("/.well-known/agent.json").then(r=>r.json()),
  getIndex:     () => fetch("/agent-assets/index.json").then(r=>r.json()),
  getPack:      (url: string) => fetch(url).then(r=>r.json()),
  getPageManifest: (routeId: string) => fetch(`/agent-assets/manifests/${routeId}.json`).then(r=>r.json()),

  // navigation (integrate with your router in real app)
  navTo: async (routeId: string) => routeId,
  currentRoute: () => document.querySelector("[data-route]")?.getAttribute("data-route"),

  // read / act / wait (demo implementations; adapt to app)
  readKPI: (routeId: string, kpiId: string) => {
    const sel = `[data-kpi='${kpiId.replaceAll("_","-")}']`;
    const el = document.querySelector(sel);
    return el ? (el.textContent||"").trim() : null;
  },

  dispatch: async (action: { type: string; payload?: any }) => {
    // In production, proxy to your backend API or local command bus
    return { ok: false, code: "UNKNOWN", error: "Implement dispatch()" };
  },

  waitFor: async (cond: any, opts: { timeoutMs?: number; pollMs?: number } = {}) => {
    const timeout = opts.timeoutMs ?? 8000, poll = opts.pollMs ?? 120;
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (cond?.type === "dom" && document.querySelector(cond.selector)) return { ok: true };
      if (cond?.type === "domAttr") {
        const el = document.querySelector(cond.selector) as HTMLElement | null;
        if (el && el.getAttribute(cond.name) === String(cond.equals)) return { ok: true };
      }
      // state/actionCompleted variants should be wired to your state store
      await new Promise(r=>setTimeout(r, poll));
    }
    return { ok: false, code: "TIMEOUT", error: "Condition not met" };
  },

  // compact page snapshot for LLM context
  snapshot: () => {
    const headings = [...document.querySelectorAll("h1,h2")].map(h=>({ level:Number(h.tagName[1]), text:(h as any).innerText?.trim() }));
    const kpis = [...document.querySelectorAll("[data-kpi]")].map(k=>({ id:k.getAttribute("data-kpi"), value:(k as any).innerText?.trim() }));
    const actions = [...document.querySelectorAll("[data-action]")].map(a=>({ id:a.getAttribute("data-action"), text:(a as any).innerText?.trim() }));
    return { url: location.href, title: document.title, headings, kpis, actions };
  }
};

5) Output Format (STRICT)

You must return exactly these sections, in order, with code blocks:

## TAGGED_HTML — the input HTML/JSX with added data-hooks only where needed.

## MANIFEST_JSON — the manifest for routeId.

## CAPABILITIES_JSON — the pack for routeId.

## BRIDGE_PATCH — the bridge snippet or patch (if missing parts).

## NOTES — short bullets: assumptions, unresolved items, and what the integrator must implement (e.g., real dispatch mapping).

Example:

## TAGGED_HTML
```html
<!-- your annotated HTML here -->

MANIFEST_JSON
{ ... }

CAPABILITIES_JSON
{ ... }

BRIDGE_PATCH
// additions/changes here

NOTES

any caveats


(Do not include anything else.)

---

## 6) Validation Checklist (you must self-check)
- [ ] Page root has `data-route` and `data-contract-version`.  
- [ ] Every manifest `selector` matches an element in TAGGED_HTML.  
- [ ] Every KPI has `type` and at least one `visibleWhen` if async.  
- [ ] Every action has **coded `errors`**.  
- [ ] Pack contains all KPIs/actions present in manifest.  
- [ ] Names follow rules (kebab for DOM, snake for manifest KPI IDs, dot for action IDs).  
- [ ] No reliance on visible text for logic.

---

## 7) Example (tiny)
**Input**  


routeId: "todo.app"
html:

<div> <h1>Todos</h1> <div> <span>0</span> <button>Add</button> </div> </div> actions: [{ id: "todo.add", command: "AddTodo", payload: { title: "string" } }] kpis: [{ id: "todos_count", type: "integer" }] namingBase: "todo" ```

Expected direction (you will produce full sections):

Wrap root with data-route="todo.app" data-contract-version="1.0.0".

Tag KPI span as data-kpi="todos-count".

Tag button as data-action="todo.add".

Manifest with KPI todos_count and action todo.add.

Pack listing those.

Bridge patch is minimal; note that dispatch needs to call backend.

8) Behavior & Exploration (hint to downstream planner)

If a user query requires a capability not in the current manifest:

The planner must look into the index packs to pick a route that has it, then emit a nav(routeId) step before acting.

This prompt only generates the contracts and tags; it doesn’t execute.